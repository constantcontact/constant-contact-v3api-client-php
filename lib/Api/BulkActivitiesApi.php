<?php
/**
 * BulkActivitiesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  ConstantContactApi\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Constant Contact API v3
 *
 * Swagger build version 3.0.53
 *
 * The version of the OpenAPI document: 1.0.167
 * Contact: webservices@constantcontact.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ConstantContactApi\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ConstantContactApi\Client\ApiException;
use ConstantContactApi\Client\Configuration;
use ConstantContactApi\Client\HeaderSelector;
use ConstantContactApi\Client\ObjectSerializer;

/**
 * BulkActivitiesApi Class Doc Comment
 *
 * @category Class
 * @package  ConstantContactApi\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BulkActivitiesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createCSVImportActivity' => [
            'multipart/form-data',
        ],
        'createDeleteActivity' => [
            'application/json',
        ],
        'createExportActivity' => [
            'application/json',
        ],
        'createImportJSONActivity' => [
            'application/json',
        ],
        'createListAddActivity' => [
            'application/json',
        ],
        'createListDeleteActivity' => [
            'application/json',
        ],
        'createListRemoveActivity' => [
            'application/json',
        ],
        'createTagAddContactActivity' => [
            'application/json',
        ],
        'createTagDeleteActivity' => [
            'application/json',
        ],
        'createTagRemoveActivity' => [
            'application/json',
        ],
        'getActivityById' => [
            'application/json',
        ],
        'getAllActivities' => [
            'application/json',
        ],
        'getCSVExportFile' => [
            'application/json',
        ],
        'postCustomFieldDelete' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCSVImportActivity
     *
     * Import Contacts using a CSV File
     *
     * @param  \SplFileObject $file The CSV file you are importing  must include either &#x60;email&#x60; or &#x60;sms_number&#x60; as a column heading. Other properties you can include using column headings are: &#x60;first_name&#x60;.  &#x60;last_name&#x60;, &#x60;phone&#x60;, &#x60;job_title&#x60;, &#x60;anniversary&#x60;, &#x60;birthday_day&#x60;, &#x60;birthday_month&#x60;, &#x60;company_name&#x60;, &#x60;street&#x60;, &#x60;street2&#x60;, &#x60;city&#x60;, &#x60;state&#x60;, &#x60;zip&#x60;, &#x60;country&#x60;, and &#x60;sms_consent_date&#x60;.   If adding an &#x60;sms_number&#x60;, you must also include the &#x60;sms_permission_to_send&#x60; parameter and set it to either &#x60;not_set&#x60; or &#x60;explicit&#x60;. If &#x60;explicit&#x60;, requires including &#x60;sms_consent_date&#x60; as a column header to specify the date the contact consented to receiving SMS messages.   You can also use custom fields as column headings. Enter the custom field name prefixed with &#x60;cf:&#x60; as the column heading. For example, use &#x60;cf:first_name&#x60; as the header name if you have a custom field named \\\&quot;first_name\\\&quot;. The custom field must already exist in the Constant Contact account you are using. Depending on the custom field data type, you can enter dates or strings as the value of the custom field. Each contact can contain up to 25 different custom fields. (required)
     * @param  string[] $list_ids Specify which contact lists you are adding all imported contacts to as an array of up to 50 contact &#x60;list_id&#x60; values. (required)
     * @param  string $sms_permission_to_send If importing contact &#x60;sms_number&#x60;s, use this parameter to specify how SMS consent was provided. If all contacts in the file provided their consent, set to &#x60;explicit&#x60; and include each contact&#39;s &#x60;sms_consent_date&#x60;. If all contacts in the file have not yet provided consent, set to &#x60;not_set&#x60; (&#x60;sms_consent_date&#x60; is not required). You cannot message a contact that does not have a sms consent date set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCSVImportActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateCSVImportActivity201Response
     */
    public function createCSVImportActivity($file, $list_ids, $sms_permission_to_send = null, string $contentType = self::contentTypes['createCSVImportActivity'][0])
    {
        list($response) = $this->createCSVImportActivityWithHttpInfo($file, $list_ids, $sms_permission_to_send, $contentType);
        return $response;
    }

    /**
     * Operation createCSVImportActivityWithHttpInfo
     *
     * Import Contacts using a CSV File
     *
     * @param  \SplFileObject $file The CSV file you are importing  must include either &#x60;email&#x60; or &#x60;sms_number&#x60; as a column heading. Other properties you can include using column headings are: &#x60;first_name&#x60;.  &#x60;last_name&#x60;, &#x60;phone&#x60;, &#x60;job_title&#x60;, &#x60;anniversary&#x60;, &#x60;birthday_day&#x60;, &#x60;birthday_month&#x60;, &#x60;company_name&#x60;, &#x60;street&#x60;, &#x60;street2&#x60;, &#x60;city&#x60;, &#x60;state&#x60;, &#x60;zip&#x60;, &#x60;country&#x60;, and &#x60;sms_consent_date&#x60;.   If adding an &#x60;sms_number&#x60;, you must also include the &#x60;sms_permission_to_send&#x60; parameter and set it to either &#x60;not_set&#x60; or &#x60;explicit&#x60;. If &#x60;explicit&#x60;, requires including &#x60;sms_consent_date&#x60; as a column header to specify the date the contact consented to receiving SMS messages.   You can also use custom fields as column headings. Enter the custom field name prefixed with &#x60;cf:&#x60; as the column heading. For example, use &#x60;cf:first_name&#x60; as the header name if you have a custom field named \\\&quot;first_name\\\&quot;. The custom field must already exist in the Constant Contact account you are using. Depending on the custom field data type, you can enter dates or strings as the value of the custom field. Each contact can contain up to 25 different custom fields. (required)
     * @param  string[] $list_ids Specify which contact lists you are adding all imported contacts to as an array of up to 50 contact &#x60;list_id&#x60; values. (required)
     * @param  string $sms_permission_to_send If importing contact &#x60;sms_number&#x60;s, use this parameter to specify how SMS consent was provided. If all contacts in the file provided their consent, set to &#x60;explicit&#x60; and include each contact&#39;s &#x60;sms_consent_date&#x60;. If all contacts in the file have not yet provided consent, set to &#x60;not_set&#x60; (&#x60;sms_consent_date&#x60; is not required). You cannot message a contact that does not have a sms consent date set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCSVImportActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateCSVImportActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCSVImportActivityWithHttpInfo($file, $list_ids, $sms_permission_to_send = null, string $contentType = self::contentTypes['createCSVImportActivity'][0])
    {
        $request = $this->createCSVImportActivityRequest($file, $list_ids, $sms_permission_to_send, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCSVImportActivityAsync
     *
     * Import Contacts using a CSV File
     *
     * @param  \SplFileObject $file The CSV file you are importing  must include either &#x60;email&#x60; or &#x60;sms_number&#x60; as a column heading. Other properties you can include using column headings are: &#x60;first_name&#x60;.  &#x60;last_name&#x60;, &#x60;phone&#x60;, &#x60;job_title&#x60;, &#x60;anniversary&#x60;, &#x60;birthday_day&#x60;, &#x60;birthday_month&#x60;, &#x60;company_name&#x60;, &#x60;street&#x60;, &#x60;street2&#x60;, &#x60;city&#x60;, &#x60;state&#x60;, &#x60;zip&#x60;, &#x60;country&#x60;, and &#x60;sms_consent_date&#x60;.   If adding an &#x60;sms_number&#x60;, you must also include the &#x60;sms_permission_to_send&#x60; parameter and set it to either &#x60;not_set&#x60; or &#x60;explicit&#x60;. If &#x60;explicit&#x60;, requires including &#x60;sms_consent_date&#x60; as a column header to specify the date the contact consented to receiving SMS messages.   You can also use custom fields as column headings. Enter the custom field name prefixed with &#x60;cf:&#x60; as the column heading. For example, use &#x60;cf:first_name&#x60; as the header name if you have a custom field named \\\&quot;first_name\\\&quot;. The custom field must already exist in the Constant Contact account you are using. Depending on the custom field data type, you can enter dates or strings as the value of the custom field. Each contact can contain up to 25 different custom fields. (required)
     * @param  string[] $list_ids Specify which contact lists you are adding all imported contacts to as an array of up to 50 contact &#x60;list_id&#x60; values. (required)
     * @param  string $sms_permission_to_send If importing contact &#x60;sms_number&#x60;s, use this parameter to specify how SMS consent was provided. If all contacts in the file provided their consent, set to &#x60;explicit&#x60; and include each contact&#39;s &#x60;sms_consent_date&#x60;. If all contacts in the file have not yet provided consent, set to &#x60;not_set&#x60; (&#x60;sms_consent_date&#x60; is not required). You cannot message a contact that does not have a sms consent date set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCSVImportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCSVImportActivityAsync($file, $list_ids, $sms_permission_to_send = null, string $contentType = self::contentTypes['createCSVImportActivity'][0])
    {
        return $this->createCSVImportActivityAsyncWithHttpInfo($file, $list_ids, $sms_permission_to_send, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCSVImportActivityAsyncWithHttpInfo
     *
     * Import Contacts using a CSV File
     *
     * @param  \SplFileObject $file The CSV file you are importing  must include either &#x60;email&#x60; or &#x60;sms_number&#x60; as a column heading. Other properties you can include using column headings are: &#x60;first_name&#x60;.  &#x60;last_name&#x60;, &#x60;phone&#x60;, &#x60;job_title&#x60;, &#x60;anniversary&#x60;, &#x60;birthday_day&#x60;, &#x60;birthday_month&#x60;, &#x60;company_name&#x60;, &#x60;street&#x60;, &#x60;street2&#x60;, &#x60;city&#x60;, &#x60;state&#x60;, &#x60;zip&#x60;, &#x60;country&#x60;, and &#x60;sms_consent_date&#x60;.   If adding an &#x60;sms_number&#x60;, you must also include the &#x60;sms_permission_to_send&#x60; parameter and set it to either &#x60;not_set&#x60; or &#x60;explicit&#x60;. If &#x60;explicit&#x60;, requires including &#x60;sms_consent_date&#x60; as a column header to specify the date the contact consented to receiving SMS messages.   You can also use custom fields as column headings. Enter the custom field name prefixed with &#x60;cf:&#x60; as the column heading. For example, use &#x60;cf:first_name&#x60; as the header name if you have a custom field named \\\&quot;first_name\\\&quot;. The custom field must already exist in the Constant Contact account you are using. Depending on the custom field data type, you can enter dates or strings as the value of the custom field. Each contact can contain up to 25 different custom fields. (required)
     * @param  string[] $list_ids Specify which contact lists you are adding all imported contacts to as an array of up to 50 contact &#x60;list_id&#x60; values. (required)
     * @param  string $sms_permission_to_send If importing contact &#x60;sms_number&#x60;s, use this parameter to specify how SMS consent was provided. If all contacts in the file provided their consent, set to &#x60;explicit&#x60; and include each contact&#39;s &#x60;sms_consent_date&#x60;. If all contacts in the file have not yet provided consent, set to &#x60;not_set&#x60; (&#x60;sms_consent_date&#x60; is not required). You cannot message a contact that does not have a sms consent date set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCSVImportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCSVImportActivityAsyncWithHttpInfo($file, $list_ids, $sms_permission_to_send = null, string $contentType = self::contentTypes['createCSVImportActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response';
        $request = $this->createCSVImportActivityRequest($file, $list_ids, $sms_permission_to_send, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCSVImportActivity'
     *
     * @param  \SplFileObject $file The CSV file you are importing  must include either &#x60;email&#x60; or &#x60;sms_number&#x60; as a column heading. Other properties you can include using column headings are: &#x60;first_name&#x60;.  &#x60;last_name&#x60;, &#x60;phone&#x60;, &#x60;job_title&#x60;, &#x60;anniversary&#x60;, &#x60;birthday_day&#x60;, &#x60;birthday_month&#x60;, &#x60;company_name&#x60;, &#x60;street&#x60;, &#x60;street2&#x60;, &#x60;city&#x60;, &#x60;state&#x60;, &#x60;zip&#x60;, &#x60;country&#x60;, and &#x60;sms_consent_date&#x60;.   If adding an &#x60;sms_number&#x60;, you must also include the &#x60;sms_permission_to_send&#x60; parameter and set it to either &#x60;not_set&#x60; or &#x60;explicit&#x60;. If &#x60;explicit&#x60;, requires including &#x60;sms_consent_date&#x60; as a column header to specify the date the contact consented to receiving SMS messages.   You can also use custom fields as column headings. Enter the custom field name prefixed with &#x60;cf:&#x60; as the column heading. For example, use &#x60;cf:first_name&#x60; as the header name if you have a custom field named \\\&quot;first_name\\\&quot;. The custom field must already exist in the Constant Contact account you are using. Depending on the custom field data type, you can enter dates or strings as the value of the custom field. Each contact can contain up to 25 different custom fields. (required)
     * @param  string[] $list_ids Specify which contact lists you are adding all imported contacts to as an array of up to 50 contact &#x60;list_id&#x60; values. (required)
     * @param  string $sms_permission_to_send If importing contact &#x60;sms_number&#x60;s, use this parameter to specify how SMS consent was provided. If all contacts in the file provided their consent, set to &#x60;explicit&#x60; and include each contact&#39;s &#x60;sms_consent_date&#x60;. If all contacts in the file have not yet provided consent, set to &#x60;not_set&#x60; (&#x60;sms_consent_date&#x60; is not required). You cannot message a contact that does not have a sms consent date set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCSVImportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCSVImportActivityRequest($file, $list_ids, $sms_permission_to_send = null, string $contentType = self::contentTypes['createCSVImportActivity'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createCSVImportActivity'
            );
        }

        // verify the required parameter 'list_ids' is set
        if ($list_ids === null || (is_array($list_ids) && count($list_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_ids when calling createCSVImportActivity'
            );
        }
        if (count($list_ids) > 50) {
            throw new \InvalidArgumentException('invalid value for "$list_ids" when calling BulkActivitiesApi.createCSVImportActivity, number of items must be less than or equal to 50.');
        }
        


        $resourcePath = '/activities/contacts_file_import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($list_ids !== null) {
            $formParams['list_ids'] = ObjectSerializer::toFormValue($list_ids);
        }
        // form params
        if ($sms_permission_to_send !== null) {
            $formParams['sms_permission_to_send'] = ObjectSerializer::toFormValue($sms_permission_to_send);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeleteActivity
     *
     * Delete Contacts in Bulk
     *
     * @param  \ConstantContactApi\Client\Model\CreateDeleteActivityRequest $create_delete_activity_request The request body contains an array of contact_ids &lt;em&gt;or&lt;/em&gt; list_ids. All contact_ids provided are deleted, or all members of each specified list_id are deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateDeleteActivity201Response
     */
    public function createDeleteActivity($create_delete_activity_request, string $contentType = self::contentTypes['createDeleteActivity'][0])
    {
        list($response) = $this->createDeleteActivityWithHttpInfo($create_delete_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeleteActivityWithHttpInfo
     *
     * Delete Contacts in Bulk
     *
     * @param  \ConstantContactApi\Client\Model\CreateDeleteActivityRequest $create_delete_activity_request The request body contains an array of contact_ids &lt;em&gt;or&lt;/em&gt; list_ids. All contact_ids provided are deleted, or all members of each specified list_id are deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateDeleteActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeleteActivityWithHttpInfo($create_delete_activity_request, string $contentType = self::contentTypes['createDeleteActivity'][0])
    {
        $request = $this->createDeleteActivityRequest($create_delete_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateDeleteActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateDeleteActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateDeleteActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateDeleteActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateDeleteActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeleteActivityAsync
     *
     * Delete Contacts in Bulk
     *
     * @param  \ConstantContactApi\Client\Model\CreateDeleteActivityRequest $create_delete_activity_request The request body contains an array of contact_ids &lt;em&gt;or&lt;/em&gt; list_ids. All contact_ids provided are deleted, or all members of each specified list_id are deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeleteActivityAsync($create_delete_activity_request, string $contentType = self::contentTypes['createDeleteActivity'][0])
    {
        return $this->createDeleteActivityAsyncWithHttpInfo($create_delete_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeleteActivityAsyncWithHttpInfo
     *
     * Delete Contacts in Bulk
     *
     * @param  \ConstantContactApi\Client\Model\CreateDeleteActivityRequest $create_delete_activity_request The request body contains an array of contact_ids &lt;em&gt;or&lt;/em&gt; list_ids. All contact_ids provided are deleted, or all members of each specified list_id are deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeleteActivityAsyncWithHttpInfo($create_delete_activity_request, string $contentType = self::contentTypes['createDeleteActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateDeleteActivity201Response';
        $request = $this->createDeleteActivityRequest($create_delete_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeleteActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateDeleteActivityRequest $create_delete_activity_request The request body contains an array of contact_ids &lt;em&gt;or&lt;/em&gt; list_ids. All contact_ids provided are deleted, or all members of each specified list_id are deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeleteActivityRequest($create_delete_activity_request, string $contentType = self::contentTypes['createDeleteActivity'][0])
    {

        // verify the required parameter 'create_delete_activity_request' is set
        if ($create_delete_activity_request === null || (is_array($create_delete_activity_request) && count($create_delete_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_delete_activity_request when calling createDeleteActivity'
            );
        }


        $resourcePath = '/activities/contact_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_delete_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_delete_activity_request));
            } else {
                $httpBody = $create_delete_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExportActivity
     *
     * Export Contacts to a File
     *
     * @param  \ConstantContactApi\Client\Model\CreateExportActivityRequest $create_export_activity_request A JSON payload that specifies the contacts (rows in the CSV file) and contact properties (columns in the CSV file) you want to export. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExportActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateExportActivity201Response
     */
    public function createExportActivity($create_export_activity_request, string $contentType = self::contentTypes['createExportActivity'][0])
    {
        list($response) = $this->createExportActivityWithHttpInfo($create_export_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createExportActivityWithHttpInfo
     *
     * Export Contacts to a File
     *
     * @param  \ConstantContactApi\Client\Model\CreateExportActivityRequest $create_export_activity_request A JSON payload that specifies the contacts (rows in the CSV file) and contact properties (columns in the CSV file) you want to export. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExportActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateExportActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExportActivityWithHttpInfo($create_export_activity_request, string $contentType = self::contentTypes['createExportActivity'][0])
    {
        $request = $this->createExportActivityRequest($create_export_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateExportActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateExportActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateExportActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateExportActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateExportActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExportActivityAsync
     *
     * Export Contacts to a File
     *
     * @param  \ConstantContactApi\Client\Model\CreateExportActivityRequest $create_export_activity_request A JSON payload that specifies the contacts (rows in the CSV file) and contact properties (columns in the CSV file) you want to export. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExportActivityAsync($create_export_activity_request, string $contentType = self::contentTypes['createExportActivity'][0])
    {
        return $this->createExportActivityAsyncWithHttpInfo($create_export_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createExportActivityAsyncWithHttpInfo
     *
     * Export Contacts to a File
     *
     * @param  \ConstantContactApi\Client\Model\CreateExportActivityRequest $create_export_activity_request A JSON payload that specifies the contacts (rows in the CSV file) and contact properties (columns in the CSV file) you want to export. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExportActivityAsyncWithHttpInfo($create_export_activity_request, string $contentType = self::contentTypes['createExportActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateExportActivity201Response';
        $request = $this->createExportActivityRequest($create_export_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExportActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateExportActivityRequest $create_export_activity_request A JSON payload that specifies the contacts (rows in the CSV file) and contact properties (columns in the CSV file) you want to export. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExportActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExportActivityRequest($create_export_activity_request, string $contentType = self::contentTypes['createExportActivity'][0])
    {

        // verify the required parameter 'create_export_activity_request' is set
        if ($create_export_activity_request === null || (is_array($create_export_activity_request) && count($create_export_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_export_activity_request when calling createExportActivity'
            );
        }


        $resourcePath = '/activities/contact_exports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_export_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_export_activity_request));
            } else {
                $httpBody = $create_export_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createImportJSONActivity
     *
     * Import Contacts using a JSON Payload
     *
     * @param  \ConstantContactApi\Client\Model\CreateImportJSONActivityRequest $create_import_json_activity_request The JSON request payload that contains the contact data and contact lists for the import. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImportJSONActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateCSVImportActivity201Response
     */
    public function createImportJSONActivity($create_import_json_activity_request, string $contentType = self::contentTypes['createImportJSONActivity'][0])
    {
        list($response) = $this->createImportJSONActivityWithHttpInfo($create_import_json_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createImportJSONActivityWithHttpInfo
     *
     * Import Contacts using a JSON Payload
     *
     * @param  \ConstantContactApi\Client\Model\CreateImportJSONActivityRequest $create_import_json_activity_request The JSON request payload that contains the contact data and contact lists for the import. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImportJSONActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateCSVImportActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createImportJSONActivityWithHttpInfo($create_import_json_activity_request, string $contentType = self::contentTypes['createImportJSONActivity'][0])
    {
        $request = $this->createImportJSONActivityRequest($create_import_json_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createImportJSONActivityAsync
     *
     * Import Contacts using a JSON Payload
     *
     * @param  \ConstantContactApi\Client\Model\CreateImportJSONActivityRequest $create_import_json_activity_request The JSON request payload that contains the contact data and contact lists for the import. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImportJSONActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImportJSONActivityAsync($create_import_json_activity_request, string $contentType = self::contentTypes['createImportJSONActivity'][0])
    {
        return $this->createImportJSONActivityAsyncWithHttpInfo($create_import_json_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createImportJSONActivityAsyncWithHttpInfo
     *
     * Import Contacts using a JSON Payload
     *
     * @param  \ConstantContactApi\Client\Model\CreateImportJSONActivityRequest $create_import_json_activity_request The JSON request payload that contains the contact data and contact lists for the import. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImportJSONActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImportJSONActivityAsyncWithHttpInfo($create_import_json_activity_request, string $contentType = self::contentTypes['createImportJSONActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateCSVImportActivity201Response';
        $request = $this->createImportJSONActivityRequest($create_import_json_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createImportJSONActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateImportJSONActivityRequest $create_import_json_activity_request The JSON request payload that contains the contact data and contact lists for the import. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImportJSONActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createImportJSONActivityRequest($create_import_json_activity_request, string $contentType = self::contentTypes['createImportJSONActivity'][0])
    {

        // verify the required parameter 'create_import_json_activity_request' is set
        if ($create_import_json_activity_request === null || (is_array($create_import_json_activity_request) && count($create_import_json_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_import_json_activity_request when calling createImportJSONActivity'
            );
        }


        $resourcePath = '/activities/contacts_json_import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_import_json_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_import_json_activity_request));
            } else {
                $httpBody = $create_import_json_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createListAddActivity
     *
     * Add Contacts to Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListAddActivityRequest $create_list_add_activity_request The JSON payload used to create the &#39;add contacts to lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListAddActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateListRemoveActivity201Response
     */
    public function createListAddActivity($create_list_add_activity_request, string $contentType = self::contentTypes['createListAddActivity'][0])
    {
        list($response) = $this->createListAddActivityWithHttpInfo($create_list_add_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createListAddActivityWithHttpInfo
     *
     * Add Contacts to Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListAddActivityRequest $create_list_add_activity_request The JSON payload used to create the &#39;add contacts to lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListAddActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateListRemoveActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createListAddActivityWithHttpInfo($create_list_add_activity_request, string $contentType = self::contentTypes['createListAddActivity'][0])
    {
        $request = $this->createListAddActivityRequest($create_list_add_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createListAddActivityAsync
     *
     * Add Contacts to Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListAddActivityRequest $create_list_add_activity_request The JSON payload used to create the &#39;add contacts to lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListAddActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListAddActivityAsync($create_list_add_activity_request, string $contentType = self::contentTypes['createListAddActivity'][0])
    {
        return $this->createListAddActivityAsyncWithHttpInfo($create_list_add_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createListAddActivityAsyncWithHttpInfo
     *
     * Add Contacts to Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListAddActivityRequest $create_list_add_activity_request The JSON payload used to create the &#39;add contacts to lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListAddActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListAddActivityAsyncWithHttpInfo($create_list_add_activity_request, string $contentType = self::contentTypes['createListAddActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response';
        $request = $this->createListAddActivityRequest($create_list_add_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createListAddActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateListAddActivityRequest $create_list_add_activity_request The JSON payload used to create the &#39;add contacts to lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListAddActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createListAddActivityRequest($create_list_add_activity_request, string $contentType = self::contentTypes['createListAddActivity'][0])
    {

        // verify the required parameter 'create_list_add_activity_request' is set
        if ($create_list_add_activity_request === null || (is_array($create_list_add_activity_request) && count($create_list_add_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_list_add_activity_request when calling createListAddActivity'
            );
        }


        $resourcePath = '/activities/add_list_memberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_list_add_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_list_add_activity_request));
            } else {
                $httpBody = $create_list_add_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createListDeleteActivity
     *
     * Delete Contact Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListDeleteActivityRequest $create_list_delete_activity_request An array of &#x60;list_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateListDeleteActivity201Response
     */
    public function createListDeleteActivity($create_list_delete_activity_request, string $contentType = self::contentTypes['createListDeleteActivity'][0])
    {
        list($response) = $this->createListDeleteActivityWithHttpInfo($create_list_delete_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createListDeleteActivityWithHttpInfo
     *
     * Delete Contact Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListDeleteActivityRequest $create_list_delete_activity_request An array of &#x60;list_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateListDeleteActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createListDeleteActivityWithHttpInfo($create_list_delete_activity_request, string $contentType = self::contentTypes['createListDeleteActivity'][0])
    {
        $request = $this->createListDeleteActivityRequest($create_list_delete_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createListDeleteActivityAsync
     *
     * Delete Contact Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListDeleteActivityRequest $create_list_delete_activity_request An array of &#x60;list_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListDeleteActivityAsync($create_list_delete_activity_request, string $contentType = self::contentTypes['createListDeleteActivity'][0])
    {
        return $this->createListDeleteActivityAsyncWithHttpInfo($create_list_delete_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createListDeleteActivityAsyncWithHttpInfo
     *
     * Delete Contact Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListDeleteActivityRequest $create_list_delete_activity_request An array of &#x60;list_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListDeleteActivityAsyncWithHttpInfo($create_list_delete_activity_request, string $contentType = self::contentTypes['createListDeleteActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateListDeleteActivity201Response';
        $request = $this->createListDeleteActivityRequest($create_list_delete_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createListDeleteActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateListDeleteActivityRequest $create_list_delete_activity_request An array of &#x60;list_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createListDeleteActivityRequest($create_list_delete_activity_request, string $contentType = self::contentTypes['createListDeleteActivity'][0])
    {

        // verify the required parameter 'create_list_delete_activity_request' is set
        if ($create_list_delete_activity_request === null || (is_array($create_list_delete_activity_request) && count($create_list_delete_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_list_delete_activity_request when calling createListDeleteActivity'
            );
        }


        $resourcePath = '/activities/list_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_list_delete_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_list_delete_activity_request));
            } else {
                $httpBody = $create_list_delete_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createListRemoveActivity
     *
     * Remove Contacts from Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListRemoveActivityRequest $create_list_remove_activity_request The JSON payload used to create the Remove Contacts from Lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListRemoveActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateListRemoveActivity201Response
     */
    public function createListRemoveActivity($create_list_remove_activity_request, string $contentType = self::contentTypes['createListRemoveActivity'][0])
    {
        list($response) = $this->createListRemoveActivityWithHttpInfo($create_list_remove_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createListRemoveActivityWithHttpInfo
     *
     * Remove Contacts from Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListRemoveActivityRequest $create_list_remove_activity_request The JSON payload used to create the Remove Contacts from Lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListRemoveActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateListRemoveActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createListRemoveActivityWithHttpInfo($create_list_remove_activity_request, string $contentType = self::contentTypes['createListRemoveActivity'][0])
    {
        $request = $this->createListRemoveActivityRequest($create_list_remove_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createListRemoveActivityAsync
     *
     * Remove Contacts from Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListRemoveActivityRequest $create_list_remove_activity_request The JSON payload used to create the Remove Contacts from Lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListRemoveActivityAsync($create_list_remove_activity_request, string $contentType = self::contentTypes['createListRemoveActivity'][0])
    {
        return $this->createListRemoveActivityAsyncWithHttpInfo($create_list_remove_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createListRemoveActivityAsyncWithHttpInfo
     *
     * Remove Contacts from Lists
     *
     * @param  \ConstantContactApi\Client\Model\CreateListRemoveActivityRequest $create_list_remove_activity_request The JSON payload used to create the Remove Contacts from Lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createListRemoveActivityAsyncWithHttpInfo($create_list_remove_activity_request, string $contentType = self::contentTypes['createListRemoveActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateListRemoveActivity201Response';
        $request = $this->createListRemoveActivityRequest($create_list_remove_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createListRemoveActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateListRemoveActivityRequest $create_list_remove_activity_request The JSON payload used to create the Remove Contacts from Lists&#39; activity (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createListRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createListRemoveActivityRequest($create_list_remove_activity_request, string $contentType = self::contentTypes['createListRemoveActivity'][0])
    {

        // verify the required parameter 'create_list_remove_activity_request' is set
        if ($create_list_remove_activity_request === null || (is_array($create_list_remove_activity_request) && count($create_list_remove_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_list_remove_activity_request when calling createListRemoveActivity'
            );
        }


        $resourcePath = '/activities/remove_list_memberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_list_remove_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_list_remove_activity_request));
            } else {
                $httpBody = $create_list_remove_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTagAddContactActivity
     *
     * Add Tags to Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that adds tags to contacts that meet your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagAddContactActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response
     */
    public function createTagAddContactActivity($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagAddContactActivity'][0])
    {
        list($response) = $this->createTagAddContactActivityWithHttpInfo($create_tag_remove_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createTagAddContactActivityWithHttpInfo
     *
     * Add Tags to Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that adds tags to contacts that meet your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagAddContactActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTagAddContactActivityWithHttpInfo($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagAddContactActivity'][0])
    {
        $request = $this->createTagAddContactActivityRequest($create_tag_remove_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTagAddContactActivityAsync
     *
     * Add Tags to Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that adds tags to contacts that meet your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagAddContactActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAddContactActivityAsync($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagAddContactActivity'][0])
    {
        return $this->createTagAddContactActivityAsyncWithHttpInfo($create_tag_remove_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTagAddContactActivityAsyncWithHttpInfo
     *
     * Add Tags to Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that adds tags to contacts that meet your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagAddContactActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagAddContactActivityAsyncWithHttpInfo($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagAddContactActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
        $request = $this->createTagAddContactActivityRequest($create_tag_remove_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTagAddContactActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that adds tags to contacts that meet your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagAddContactActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTagAddContactActivityRequest($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagAddContactActivity'][0])
    {

        // verify the required parameter 'create_tag_remove_activity_request' is set
        if ($create_tag_remove_activity_request === null || (is_array($create_tag_remove_activity_request) && count($create_tag_remove_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_tag_remove_activity_request when calling createTagAddContactActivity'
            );
        }


        $resourcePath = '/activities/contacts_taggings_add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_tag_remove_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_tag_remove_activity_request));
            } else {
                $httpBody = $create_tag_remove_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTagDeleteActivity
     *
     * Delete Tags
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagDeleteActivityRequest $create_tag_delete_activity_request An array of string values (&#x60;tag_id&#x60;s) to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response
     */
    public function createTagDeleteActivity($create_tag_delete_activity_request, string $contentType = self::contentTypes['createTagDeleteActivity'][0])
    {
        list($response) = $this->createTagDeleteActivityWithHttpInfo($create_tag_delete_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createTagDeleteActivityWithHttpInfo
     *
     * Delete Tags
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagDeleteActivityRequest $create_tag_delete_activity_request An array of string values (&#x60;tag_id&#x60;s) to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagDeleteActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTagDeleteActivityWithHttpInfo($create_tag_delete_activity_request, string $contentType = self::contentTypes['createTagDeleteActivity'][0])
    {
        $request = $this->createTagDeleteActivityRequest($create_tag_delete_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTagDeleteActivityAsync
     *
     * Delete Tags
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagDeleteActivityRequest $create_tag_delete_activity_request An array of string values (&#x60;tag_id&#x60;s) to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagDeleteActivityAsync($create_tag_delete_activity_request, string $contentType = self::contentTypes['createTagDeleteActivity'][0])
    {
        return $this->createTagDeleteActivityAsyncWithHttpInfo($create_tag_delete_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTagDeleteActivityAsyncWithHttpInfo
     *
     * Delete Tags
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagDeleteActivityRequest $create_tag_delete_activity_request An array of string values (&#x60;tag_id&#x60;s) to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagDeleteActivityAsyncWithHttpInfo($create_tag_delete_activity_request, string $contentType = self::contentTypes['createTagDeleteActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
        $request = $this->createTagDeleteActivityRequest($create_tag_delete_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTagDeleteActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagDeleteActivityRequest $create_tag_delete_activity_request An array of string values (&#x60;tag_id&#x60;s) to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagDeleteActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTagDeleteActivityRequest($create_tag_delete_activity_request, string $contentType = self::contentTypes['createTagDeleteActivity'][0])
    {

        // verify the required parameter 'create_tag_delete_activity_request' is set
        if ($create_tag_delete_activity_request === null || (is_array($create_tag_delete_activity_request) && count($create_tag_delete_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_tag_delete_activity_request when calling createTagDeleteActivity'
            );
        }


        $resourcePath = '/activities/contacts_tags_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_tag_delete_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_tag_delete_activity_request));
            } else {
                $httpBody = $create_tag_delete_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTagRemoveActivity
     *
     * Remove Tags from Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that removes tags from contacts meeting your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagRemoveActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response
     */
    public function createTagRemoveActivity($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagRemoveActivity'][0])
    {
        list($response) = $this->createTagRemoveActivityWithHttpInfo($create_tag_remove_activity_request, $contentType);
        return $response;
    }

    /**
     * Operation createTagRemoveActivityWithHttpInfo
     *
     * Remove Tags from Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that removes tags from contacts meeting your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagRemoveActivity'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTagRemoveActivityWithHttpInfo($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagRemoveActivity'][0])
    {
        $request = $this->createTagRemoveActivityRequest($create_tag_remove_activity_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTagRemoveActivityAsync
     *
     * Remove Tags from Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that removes tags from contacts meeting your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagRemoveActivityAsync($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagRemoveActivity'][0])
    {
        return $this->createTagRemoveActivityAsyncWithHttpInfo($create_tag_remove_activity_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTagRemoveActivityAsyncWithHttpInfo
     *
     * Remove Tags from Contacts
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that removes tags from contacts meeting your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTagRemoveActivityAsyncWithHttpInfo($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagRemoveActivity'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\CreateTagRemoveActivity201Response';
        $request = $this->createTagRemoveActivityRequest($create_tag_remove_activity_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTagRemoveActivity'
     *
     * @param  \ConstantContactApi\Client\Model\CreateTagRemoveActivityRequest $create_tag_remove_activity_request The JSON payload used to create an asynchronous activity that removes tags from contacts meeting your specified contact filtering criteria. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTagRemoveActivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTagRemoveActivityRequest($create_tag_remove_activity_request, string $contentType = self::contentTypes['createTagRemoveActivity'][0])
    {

        // verify the required parameter 'create_tag_remove_activity_request' is set
        if ($create_tag_remove_activity_request === null || (is_array($create_tag_remove_activity_request) && count($create_tag_remove_activity_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_tag_remove_activity_request when calling createTagRemoveActivity'
            );
        }


        $resourcePath = '/activities/contacts_taggings_remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_tag_remove_activity_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_tag_remove_activity_request));
            } else {
                $httpBody = $create_tag_remove_activity_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityById
     *
     * GET an Activity Status
     *
     * @param  string $activity_id The unique ID of the activity to GET (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivityById'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\GetActivityById200Response
     */
    public function getActivityById($activity_id, string $contentType = self::contentTypes['getActivityById'][0])
    {
        list($response) = $this->getActivityByIdWithHttpInfo($activity_id, $contentType);
        return $response;
    }

    /**
     * Operation getActivityByIdWithHttpInfo
     *
     * GET an Activity Status
     *
     * @param  string $activity_id The unique ID of the activity to GET (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivityById'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\GetActivityById200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityByIdWithHttpInfo($activity_id, string $contentType = self::contentTypes['getActivityById'][0])
    {
        $request = $this->getActivityByIdRequest($activity_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ConstantContactApi\Client\Model\GetActivityById200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\GetActivityById200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\GetActivityById200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\GetActivityById200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\GetActivityById200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityByIdAsync
     *
     * GET an Activity Status
     *
     * @param  string $activity_id The unique ID of the activity to GET (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivityById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityByIdAsync($activity_id, string $contentType = self::contentTypes['getActivityById'][0])
    {
        return $this->getActivityByIdAsyncWithHttpInfo($activity_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityByIdAsyncWithHttpInfo
     *
     * GET an Activity Status
     *
     * @param  string $activity_id The unique ID of the activity to GET (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivityById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityByIdAsyncWithHttpInfo($activity_id, string $contentType = self::contentTypes['getActivityById'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\GetActivityById200Response';
        $request = $this->getActivityByIdRequest($activity_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityById'
     *
     * @param  string $activity_id The unique ID of the activity to GET (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActivityById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getActivityByIdRequest($activity_id, string $contentType = self::contentTypes['getActivityById'][0])
    {

        // verify the required parameter 'activity_id' is set
        if ($activity_id === null || (is_array($activity_id) && count($activity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activity_id when calling getActivityById'
            );
        }


        $resourcePath = '/activities/{activity_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($activity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'activity_id' . '}',
                ObjectSerializer::toPathValue($activity_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllActivities
     *
     * GET Activity Status Collection
     *
     * @param  int $limit Specifies the number of results displayed per page of output, from 1 - 500, default &#x3D; 50. (optional, default to 50)
     * @param  string $state Use this parameter to filter the response to include only activities in one of the following states: cancelled, completed, failed, processing, or timed_out. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllActivities'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\GetAllActivities200Response
     */
    public function getAllActivities($limit = 50, $state = null, string $contentType = self::contentTypes['getAllActivities'][0])
    {
        list($response) = $this->getAllActivitiesWithHttpInfo($limit, $state, $contentType);
        return $response;
    }

    /**
     * Operation getAllActivitiesWithHttpInfo
     *
     * GET Activity Status Collection
     *
     * @param  int $limit Specifies the number of results displayed per page of output, from 1 - 500, default &#x3D; 50. (optional, default to 50)
     * @param  string $state Use this parameter to filter the response to include only activities in one of the following states: cancelled, completed, failed, processing, or timed_out. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllActivities'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\GetAllActivities200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllActivitiesWithHttpInfo($limit = 50, $state = null, string $contentType = self::contentTypes['getAllActivities'][0])
    {
        $request = $this->getAllActivitiesRequest($limit, $state, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ConstantContactApi\Client\Model\GetAllActivities200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\GetAllActivities200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\GetAllActivities200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\GetAllActivities200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\GetAllActivities200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllActivitiesAsync
     *
     * GET Activity Status Collection
     *
     * @param  int $limit Specifies the number of results displayed per page of output, from 1 - 500, default &#x3D; 50. (optional, default to 50)
     * @param  string $state Use this parameter to filter the response to include only activities in one of the following states: cancelled, completed, failed, processing, or timed_out. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllActivitiesAsync($limit = 50, $state = null, string $contentType = self::contentTypes['getAllActivities'][0])
    {
        return $this->getAllActivitiesAsyncWithHttpInfo($limit, $state, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllActivitiesAsyncWithHttpInfo
     *
     * GET Activity Status Collection
     *
     * @param  int $limit Specifies the number of results displayed per page of output, from 1 - 500, default &#x3D; 50. (optional, default to 50)
     * @param  string $state Use this parameter to filter the response to include only activities in one of the following states: cancelled, completed, failed, processing, or timed_out. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllActivitiesAsyncWithHttpInfo($limit = 50, $state = null, string $contentType = self::contentTypes['getAllActivities'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\GetAllActivities200Response';
        $request = $this->getAllActivitiesRequest($limit, $state, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllActivities'
     *
     * @param  int $limit Specifies the number of results displayed per page of output, from 1 - 500, default &#x3D; 50. (optional, default to 50)
     * @param  string $state Use this parameter to filter the response to include only activities in one of the following states: cancelled, completed, failed, processing, or timed_out. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllActivities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllActivitiesRequest($limit = 50, $state = null, string $contentType = self::contentTypes['getAllActivities'][0])
    {

        if ($limit !== null && $limit > 500) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling BulkActivitiesApi.getAllActivities, must be smaller than or equal to 500.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling BulkActivitiesApi.getAllActivities, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/activities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCSVExportFile
     *
     * Retrieve Exported Contacts File
     *
     * @param  string $file_export_id The unique ID of the exported file provided in the results: section of the export contacts activity response. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCSVExportFile'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getCSVExportFile($file_export_id, string $contentType = self::contentTypes['getCSVExportFile'][0])
    {
        list($response) = $this->getCSVExportFileWithHttpInfo($file_export_id, $contentType);
        return $response;
    }

    /**
     * Operation getCSVExportFileWithHttpInfo
     *
     * Retrieve Exported Contacts File
     *
     * @param  string $file_export_id The unique ID of the exported file provided in the results: section of the export contacts activity response. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCSVExportFile'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCSVExportFileWithHttpInfo($file_export_id, string $contentType = self::contentTypes['getCSVExportFile'][0])
    {
        $request = $this->getCSVExportFileRequest($file_export_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCSVExportFileAsync
     *
     * Retrieve Exported Contacts File
     *
     * @param  string $file_export_id The unique ID of the exported file provided in the results: section of the export contacts activity response. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCSVExportFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCSVExportFileAsync($file_export_id, string $contentType = self::contentTypes['getCSVExportFile'][0])
    {
        return $this->getCSVExportFileAsyncWithHttpInfo($file_export_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCSVExportFileAsyncWithHttpInfo
     *
     * Retrieve Exported Contacts File
     *
     * @param  string $file_export_id The unique ID of the exported file provided in the results: section of the export contacts activity response. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCSVExportFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCSVExportFileAsyncWithHttpInfo($file_export_id, string $contentType = self::contentTypes['getCSVExportFile'][0])
    {
        $returnType = 'string';
        $request = $this->getCSVExportFileRequest($file_export_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCSVExportFile'
     *
     * @param  string $file_export_id The unique ID of the exported file provided in the results: section of the export contacts activity response. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCSVExportFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCSVExportFileRequest($file_export_id, string $contentType = self::contentTypes['getCSVExportFile'][0])
    {

        // verify the required parameter 'file_export_id' is set
        if ($file_export_id === null || (is_array($file_export_id) && count($file_export_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_export_id when calling getCSVExportFile'
            );
        }


        $resourcePath = '/contact_exports/{file_export_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_export_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_export_id' . '}',
                ObjectSerializer::toPathValue($file_export_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCustomFieldDelete
     *
     * Delete Custom Fields
     *
     * @param  \ConstantContactApi\Client\Model\PostCustomFieldDeleteRequest $post_custom_field_delete_request An array of &#x60;custom_field_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCustomFieldDelete'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ConstantContactApi\Client\Model\PostCustomFieldDelete201Response
     */
    public function postCustomFieldDelete($post_custom_field_delete_request, string $contentType = self::contentTypes['postCustomFieldDelete'][0])
    {
        list($response) = $this->postCustomFieldDeleteWithHttpInfo($post_custom_field_delete_request, $contentType);
        return $response;
    }

    /**
     * Operation postCustomFieldDeleteWithHttpInfo
     *
     * Delete Custom Fields
     *
     * @param  \ConstantContactApi\Client\Model\PostCustomFieldDeleteRequest $post_custom_field_delete_request An array of &#x60;custom_field_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCustomFieldDelete'] to see the possible values for this operation
     *
     * @throws \ConstantContactApi\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ConstantContactApi\Client\Model\PostCustomFieldDelete201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCustomFieldDeleteWithHttpInfo($post_custom_field_delete_request, string $contentType = self::contentTypes['postCustomFieldDelete'][0])
    {
        $request = $this->postCustomFieldDeleteRequest($post_custom_field_delete_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCustomFieldDeleteAsync
     *
     * Delete Custom Fields
     *
     * @param  \ConstantContactApi\Client\Model\PostCustomFieldDeleteRequest $post_custom_field_delete_request An array of &#x60;custom_field_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCustomFieldDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCustomFieldDeleteAsync($post_custom_field_delete_request, string $contentType = self::contentTypes['postCustomFieldDelete'][0])
    {
        return $this->postCustomFieldDeleteAsyncWithHttpInfo($post_custom_field_delete_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCustomFieldDeleteAsyncWithHttpInfo
     *
     * Delete Custom Fields
     *
     * @param  \ConstantContactApi\Client\Model\PostCustomFieldDeleteRequest $post_custom_field_delete_request An array of &#x60;custom_field_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCustomFieldDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCustomFieldDeleteAsyncWithHttpInfo($post_custom_field_delete_request, string $contentType = self::contentTypes['postCustomFieldDelete'][0])
    {
        $returnType = '\ConstantContactApi\Client\Model\PostCustomFieldDelete201Response';
        $request = $this->postCustomFieldDeleteRequest($post_custom_field_delete_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCustomFieldDelete'
     *
     * @param  \ConstantContactApi\Client\Model\PostCustomFieldDeleteRequest $post_custom_field_delete_request An array of &#x60;custom_field_id&#x60;&#39;s to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postCustomFieldDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postCustomFieldDeleteRequest($post_custom_field_delete_request, string $contentType = self::contentTypes['postCustomFieldDelete'][0])
    {

        // verify the required parameter 'post_custom_field_delete_request' is set
        if ($post_custom_field_delete_request === null || (is_array($post_custom_field_delete_request) && count($post_custom_field_delete_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_custom_field_delete_request when calling postCustomFieldDelete'
            );
        }


        $resourcePath = '/activities/custom_fields_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_custom_field_delete_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_custom_field_delete_request));
            } else {
                $httpBody = $post_custom_field_delete_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
